

                    solidfmm â€“ Wir ziehen alle Register!

                                   HOWTO

================================================================================

Creating a multipole expansion.

================================================================================

Given point charges i = 1, ..., N at location x[i], y[i], z[i] and charge mu[i],
compute multipole expansion of order P around expansion centre xc, yc, zc.

Needed headers:
#include <solidfmm/solid.hpp>
#include <solidfmm/harmonics.hpp>


Given data, initialised somewhere else:
size_t P;                // Order of multipole expansion
double x[N], y[N], z[N]; // Given coordinates of point charges
double mu[N];            // Charge/Mass of the particles.
double xc, yc, zc;       // Expansion centre.


The actual computation then looks as follows:
using solidfmm::harmonics::R; // Evaluates the *R*egular solid harmonics.

solidfmm::solid<double> M(P);     // Creates zero coefficients of order P in double precision.
for ( size_t i = 0; i < N; ++i )
{
    solidfmm::fmadd( mu[i], R<double>(P,x[i]-xc,y[i]-yc,z-z[i]), M );
}

Analogous for single precision: just replace
"double" with float.

================================================================================

Evaluating a multipole expansion.

================================================================================

Needed headers:
#include <solidfmm/solid.hpp>
#include <solidfmm/harmonics.hpp>

Given data, initialised somewhere else:
solidfmm::solid<double> M;  // Multipole coefficients.
double xc, yc, zc;          // Centre of the expansion
double x,  y,  z;           // Location where the expansion should be evaluated.

To evaluate the multipole expansion:
using solidfmm::harmonics::S; // Evaluates the *S*ingular solid harmonics.
double result = 0;
solidfmm::dot( M, S<double>( M.order(), x-xc, y-yc, z-zc ), &result );


================================================================================

Evaluating a local expansion.

================================================================================

Needed headers:
#include <solidfmm/solid.hpp>
#include <solidfmm/harmonics.hpp>

Given data, initialised somewhere else:
solidfmm::solid<double> L;  // Local coefficients.
double xc, yc, zc;          // Centre of the expansion
double x,  y,  z;           // Location where the expansion should be evaluated.

To evaluate the multipole expansion:
using solidfmm::harmonics::R; // Evaluates the *R*ingular solid harmonics.
double result = 0;
solidfmm::dot( L, R<double>( L.order(), x-xc, y-yc, z-zc ), &result );


================================================================================

M2M, M2L, and L2L translations.

================================================================================

Needed headers:
#include <solidfmm/solid.hpp>
#include <solidfmm/handles.hpp>
#include <solidfmm/translations.hpp>

Given data, initialised somewhere else:
size_t howmany;                    // How many translations do you want to carry out?
solidfmm::solid<double> **input;   // ARRAY OF POINTERS of size howmany to the input  coefficients
solidfmm::solid<double> **output;  // ARRAY OF POINTERS of size howmany to the output coefficients

double xshift[howmany]; // Shift vectors for the translations.
double yshift[howmany];
double zshift[howmany];


size_t Pmax; // The highest order of expansions you are ever going to use.
solidfmm::operator_handle<double>    op( Pmax );
solidfmm::  buffer_handle<double>   buf( op   ); 

operator_handle may and should be shared among threads. However, each thread will
need its own, private buffer_handle.  Generation of operator_handle and
buffer_handle is relatively expensive. Do this only once at programme start-up and
then reuse them.

To perform the actual translation:

solidfmm::m2l( op, buf, howmany, input, output, xshift, yshift, zshift );


m2m and l2l are called analogously. The result of input[i] is *added* to output[i].

Suppose you have 200 input expasions that you want to accumulate into
a single output expansion L. To achieve this, set
output[0] = output[1] = ... = output[199] = &L;
That is, just repeat the output pointer.

Simularly, input pointers can also be repeated if you want to translate one
source to many targets. To make maximum use of the vectorisation, always call these
operations with "howmany" as big as possible. That is, do *not* call m2l
200 times with howmany = 1.

You may call m2m, m2l, and l2l simultaneuously from several therads. In this
case, each thread needs its own buffer. You cannot have different threads
write to the same output, this will cause a race condition and undefined results.

Note that these operations support mixed orders! Make sure that the output
expansions are initialised and have the correct order P! Default
constructed objects of type solid<double> will have order P = 0, so then
nothing happens.

If in doubt, before doing the translation, you may call:

for ( size_t i = 0; i < howmany; ++i )
{
    output[i]->resize( P ); // Choose your desired output order here.
    output[i]->zeros();     // Set all coefficients to zero.
}

and now call m2l.

